<html>
<head>
<title>METADATA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.ln { color: #606366; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
METADATA</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">Metadata-Version: 2.1</span>
<a name="l2"><span class="ln">2    </span></a><span class="s0">Name: email-validator</span>
<a name="l3"><span class="ln">3    </span></a><span class="s0">Version: 1.3.0</span>
<a name="l4"><span class="ln">4    </span></a><span class="s0">Summary: A robust email address syntax and deliverability validation library.</span>
<a name="l5"><span class="ln">5    </span></a><span class="s0">Home-page: https://github.com/JoshData/python-email-validator</span>
<a name="l6"><span class="ln">6    </span></a><span class="s0">Author: Joshua Tauberer</span>
<a name="l7"><span class="ln">7    </span></a><span class="s0">Author-email: jt@occams.info</span>
<a name="l8"><span class="ln">8    </span></a><span class="s0">License: CC0 (copyright waived)</span>
<a name="l9"><span class="ln">9    </span></a><span class="s0">Keywords: email address validator</span>
<a name="l10"><span class="ln">10   </span></a><span class="s0">Platform: UNKNOWN</span>
<a name="l11"><span class="ln">11   </span></a><span class="s0">Classifier: Development Status :: 5 - Production/Stable</span>
<a name="l12"><span class="ln">12   </span></a><span class="s0">Classifier: Intended Audience :: Developers</span>
<a name="l13"><span class="ln">13   </span></a><span class="s0">Classifier: License :: CC0 1.0 Universal (CC0 1.0) Public Domain Dedication</span>
<a name="l14"><span class="ln">14   </span></a><span class="s0">Classifier: Programming Language :: Python :: 2</span>
<a name="l15"><span class="ln">15   </span></a><span class="s0">Classifier: Programming Language :: Python :: 2.7</span>
<a name="l16"><span class="ln">16   </span></a><span class="s0">Classifier: Programming Language :: Python :: 3</span>
<a name="l17"><span class="ln">17   </span></a><span class="s0">Classifier: Programming Language :: Python :: 3.7</span>
<a name="l18"><span class="ln">18   </span></a><span class="s0">Classifier: Programming Language :: Python :: 3.8</span>
<a name="l19"><span class="ln">19   </span></a><span class="s0">Classifier: Programming Language :: Python :: 3.9</span>
<a name="l20"><span class="ln">20   </span></a><span class="s0">Classifier: Programming Language :: Python :: 3.10</span>
<a name="l21"><span class="ln">21   </span></a><span class="s0">Classifier: Topic :: Software Development :: Libraries :: Python Modules</span>
<a name="l22"><span class="ln">22   </span></a><span class="s0">Requires-Python: !=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,&gt;=2.7</span>
<a name="l23"><span class="ln">23   </span></a><span class="s0">Description-Content-Type: text/markdown</span>
<a name="l24"><span class="ln">24   </span></a><span class="s0">License-File: LICENSE</span>
<a name="l25"><span class="ln">25   </span></a><span class="s0">Requires-Dist: dnspython (&gt;=1.15.0)</span>
<a name="l26"><span class="ln">26   </span></a><span class="s0">Requires-Dist: idna (&gt;=2.0.0)</span>
<a name="l27"><span class="ln">27   </span></a>
<a name="l28"><span class="ln">28   </span></a><span class="s0">email-validator: Validate Email Addresses</span>
<a name="l29"><span class="ln">29   </span></a><span class="s0">=========================================</span>
<a name="l30"><span class="ln">30   </span></a>
<a name="l31"><span class="ln">31   </span></a><span class="s0">A robust email address syntax and deliverability validation library for</span>
<a name="l32"><span class="ln">32   </span></a><span class="s0">Python by [Joshua Tauberer](https://joshdata.me).</span>
<a name="l33"><span class="ln">33   </span></a>
<a name="l34"><span class="ln">34   </span></a><span class="s0">This library validates that a string is of the form `name@example.com`. This is</span>
<a name="l35"><span class="ln">35   </span></a><span class="s0">the sort of validation you would want for an email-based login form on </span>
<a name="l36"><span class="ln">36   </span></a><span class="s0">a website.</span>
<a name="l37"><span class="ln">37   </span></a>
<a name="l38"><span class="ln">38   </span></a><span class="s0">Key features:</span>
<a name="l39"><span class="ln">39   </span></a>
<a name="l40"><span class="ln">40   </span></a><span class="s0">* Checks that an email address has the correct syntax --- good for</span>
<a name="l41"><span class="ln">41   </span></a>  <span class="s0">login forms or other uses related to identifying users.</span>
<a name="l42"><span class="ln">42   </span></a><span class="s0">* Gives friendly error messages when validation fails (appropriate to show</span>
<a name="l43"><span class="ln">43   </span></a>  <span class="s0">to end users).</span>
<a name="l44"><span class="ln">44   </span></a><span class="s0">* (optionally) Checks deliverability: Does the domain name resolve? And you can override the default DNS resolver.</span>
<a name="l45"><span class="ln">45   </span></a><span class="s0">* Supports internationalized domain names and (optionally)</span>
<a name="l46"><span class="ln">46   </span></a>  <span class="s0">internationalized local parts, but blocks unsafe characters.</span>
<a name="l47"><span class="ln">47   </span></a><span class="s0">* Normalizes email addresses (super important for internationalized</span>
<a name="l48"><span class="ln">48   </span></a>  <span class="s0">addresses! see below).</span>
<a name="l49"><span class="ln">49   </span></a>
<a name="l50"><span class="ln">50   </span></a><span class="s0">The library is NOT for validation of the To: line in an email message</span>
<a name="l51"><span class="ln">51   </span></a><span class="s0">(e.g. `My Name &lt;my@address.com&gt;`), which</span>
<a name="l52"><span class="ln">52   </span></a><span class="s0">[flanker](https://github.com/mailgun/flanker) is more appropriate for.</span>
<a name="l53"><span class="ln">53   </span></a><span class="s0">And this library does NOT permit obsolete forms of email addresses, so</span>
<a name="l54"><span class="ln">54   </span></a><span class="s0">if you need strict validation against the email specs exactly, use</span>
<a name="l55"><span class="ln">55   </span></a><span class="s0">[pyIsEmail](https://github.com/michaelherold/pyIsEmail).</span>
<a name="l56"><span class="ln">56   </span></a>
<a name="l57"><span class="ln">57   </span></a><span class="s0">This library is tested with Python 3.6+ but should work in earlier versions:</span>
<a name="l58"><span class="ln">58   </span></a>
<a name="l59"><span class="ln">59   </span></a><span class="s0">[![Build Status](https://app.travis-ci.com/JoshData/python-email-validator.svg?branch=main)](https://app.travis-ci.com/JoshData/python-email-validator)</span>
<a name="l60"><span class="ln">60   </span></a>
<a name="l61"><span class="ln">61   </span></a><span class="s0">View the [CHANGELOG / Release Notes](CHANGELOG.md) for the version history of changes in the library. Occasionally this README is ahead of the latest published package --- see the CHANGELOG for details.</span>
<a name="l62"><span class="ln">62   </span></a>
<a name="l63"><span class="ln">63   </span></a><span class="s0">---</span>
<a name="l64"><span class="ln">64   </span></a>
<a name="l65"><span class="ln">65   </span></a><span class="s0">Installation</span>
<a name="l66"><span class="ln">66   </span></a><span class="s0">------------</span>
<a name="l67"><span class="ln">67   </span></a>
<a name="l68"><span class="ln">68   </span></a><span class="s0">This package [is on PyPI](https://pypi.org/project/email-validator/), so:</span>
<a name="l69"><span class="ln">69   </span></a>
<a name="l70"><span class="ln">70   </span></a><span class="s0">```sh</span>
<a name="l71"><span class="ln">71   </span></a><span class="s0">pip install email-validator</span>
<a name="l72"><span class="ln">72   </span></a><span class="s0">```</span>
<a name="l73"><span class="ln">73   </span></a>
<a name="l74"><span class="ln">74   </span></a><span class="s0">`pip3` also works.</span>
<a name="l75"><span class="ln">75   </span></a>
<a name="l76"><span class="ln">76   </span></a><span class="s0">Quick Start</span>
<a name="l77"><span class="ln">77   </span></a><span class="s0">-----------</span>
<a name="l78"><span class="ln">78   </span></a>
<a name="l79"><span class="ln">79   </span></a><span class="s0">If you're validating a user's email address before creating a user</span>
<a name="l80"><span class="ln">80   </span></a><span class="s0">account in your application, you might do this:</span>
<a name="l81"><span class="ln">81   </span></a>
<a name="l82"><span class="ln">82   </span></a><span class="s0">```python</span>
<a name="l83"><span class="ln">83   </span></a><span class="s0">from email_validator import validate_email, EmailNotValidError</span>
<a name="l84"><span class="ln">84   </span></a>
<a name="l85"><span class="ln">85   </span></a><span class="s0">email = &quot;my+address@mydomain.tld&quot;</span>
<a name="l86"><span class="ln">86   </span></a><span class="s0">is_new_account = True # False for login pages</span>
<a name="l87"><span class="ln">87   </span></a>
<a name="l88"><span class="ln">88   </span></a><span class="s0">try:</span>
<a name="l89"><span class="ln">89   </span></a>  <span class="s0"># Check that the email address is valid.</span>
<a name="l90"><span class="ln">90   </span></a>  <span class="s0">validation = validate_email(email, check_deliverability=is_new_account)</span>
<a name="l91"><span class="ln">91   </span></a>
<a name="l92"><span class="ln">92   </span></a>  <span class="s0"># Take the normalized form of the email address</span>
<a name="l93"><span class="ln">93   </span></a>  <span class="s0"># for all logic beyond this point (especially</span>
<a name="l94"><span class="ln">94   </span></a>  <span class="s0"># before going to a database query where equality</span>
<a name="l95"><span class="ln">95   </span></a>  <span class="s0"># may not take into account Unicode normalization).  </span>
<a name="l96"><span class="ln">96   </span></a>  <span class="s0">email = validation.email</span>
<a name="l97"><span class="ln">97   </span></a><span class="s0">except EmailNotValidError as e:</span>
<a name="l98"><span class="ln">98   </span></a>  <span class="s0"># Email is not valid.</span>
<a name="l99"><span class="ln">99   </span></a>  <span class="s0"># The exception message is human-readable.</span>
<a name="l100"><span class="ln">100  </span></a>  <span class="s0">print(str(e))</span>
<a name="l101"><span class="ln">101  </span></a><span class="s0">```</span>
<a name="l102"><span class="ln">102  </span></a>
<a name="l103"><span class="ln">103  </span></a><span class="s0">This validates the address and gives you its normalized form. You should</span>
<a name="l104"><span class="ln">104  </span></a><span class="s0">**put the normalized form in your database** and always normalize before</span>
<a name="l105"><span class="ln">105  </span></a><span class="s0">checking if an address is in your database. When using this in a login form,</span>
<a name="l106"><span class="ln">106  </span></a><span class="s0">set `check_deliverability` to `False` to avoid unnecessary DNS queries.</span>
<a name="l107"><span class="ln">107  </span></a>
<a name="l108"><span class="ln">108  </span></a><span class="s0">Usage</span>
<a name="l109"><span class="ln">109  </span></a><span class="s0">-----</span>
<a name="l110"><span class="ln">110  </span></a>
<a name="l111"><span class="ln">111  </span></a><span class="s0">### Overview</span>
<a name="l112"><span class="ln">112  </span></a>
<a name="l113"><span class="ln">113  </span></a><span class="s0">The module provides a function `validate_email(email_address)` which</span>
<a name="l114"><span class="ln">114  </span></a><span class="s0">takes an email address (either a `str` or `bytes`, but only non-internationalized</span>
<a name="l115"><span class="ln">115  </span></a><span class="s0">addresses are allowed when passing a `bytes`) and:</span>
<a name="l116"><span class="ln">116  </span></a>
<a name="l117"><span class="ln">117  </span></a><span class="s0">- Raises a `EmailNotValidError` with a helpful, human-readable error</span>
<a name="l118"><span class="ln">118  </span></a>  <span class="s0">message explaining why the email address is not valid, or</span>
<a name="l119"><span class="ln">119  </span></a><span class="s0">- Returns an object with a normalized form of the email address (which</span>
<a name="l120"><span class="ln">120  </span></a>  <span class="s0">you should use!) and other information about it.</span>
<a name="l121"><span class="ln">121  </span></a>
<a name="l122"><span class="ln">122  </span></a><span class="s0">When an email address is not valid, `validate_email` raises either an</span>
<a name="l123"><span class="ln">123  </span></a><span class="s0">`EmailSyntaxError` if the form of the address is invalid or an</span>
<a name="l124"><span class="ln">124  </span></a><span class="s0">`EmailUndeliverableError` if the domain name fails DNS checks. Both</span>
<a name="l125"><span class="ln">125  </span></a><span class="s0">exception classes are subclasses of `EmailNotValidError`, which in turn</span>
<a name="l126"><span class="ln">126  </span></a><span class="s0">is a subclass of `ValueError`.</span>
<a name="l127"><span class="ln">127  </span></a>
<a name="l128"><span class="ln">128  </span></a><span class="s0">But when an email address is valid, an object is returned containing</span>
<a name="l129"><span class="ln">129  </span></a><span class="s0">a normalized form of the email address (which you should use!) and</span>
<a name="l130"><span class="ln">130  </span></a><span class="s0">other information.</span>
<a name="l131"><span class="ln">131  </span></a>
<a name="l132"><span class="ln">132  </span></a><span class="s0">The validator doesn't permit obsoleted forms of email addresses that no</span>
<a name="l133"><span class="ln">133  </span></a><span class="s0">one uses anymore even though they are still valid and deliverable, since</span>
<a name="l134"><span class="ln">134  </span></a><span class="s0">they will probably give you grief if you're using email for login. (See</span>
<a name="l135"><span class="ln">135  </span></a><span class="s0">later in the document about that.)</span>
<a name="l136"><span class="ln">136  </span></a>
<a name="l137"><span class="ln">137  </span></a><span class="s0">The validator checks that the domain name in the email address has a</span>
<a name="l138"><span class="ln">138  </span></a><span class="s0">DNS MX record (except a NULL MX record) indicating that it can receive</span>
<a name="l139"><span class="ln">139  </span></a><span class="s0">email and that it does not have a reject-all SPF record (`v=spf1 -all`)</span>
<a name="l140"><span class="ln">140  </span></a><span class="s0">which would indicate that it cannot send email.</span>
<a name="l141"><span class="ln">141  </span></a><span class="s0">There is nothing to be gained by trying to actually contact an SMTP</span>
<a name="l142"><span class="ln">142  </span></a><span class="s0">server, so that's not done here. For privacy, security, and practicality</span>
<a name="l143"><span class="ln">143  </span></a><span class="s0">reasons servers are good at not giving away whether an address is</span>
<a name="l144"><span class="ln">144  </span></a><span class="s0">deliverable or not: email addresses that appear to accept mail at first</span>
<a name="l145"><span class="ln">145  </span></a><span class="s0">can bounce mail after a delay, and bounced mail may indicate a temporary</span>
<a name="l146"><span class="ln">146  </span></a><span class="s0">failure of a good email address (sometimes an intentional failure, like</span>
<a name="l147"><span class="ln">147  </span></a><span class="s0">greylisting).</span>
<a name="l148"><span class="ln">148  </span></a>
<a name="l149"><span class="ln">149  </span></a><span class="s0">### Options</span>
<a name="l150"><span class="ln">150  </span></a>
<a name="l151"><span class="ln">151  </span></a><span class="s0">The `validate_email` function also accepts the following keyword arguments</span>
<a name="l152"><span class="ln">152  </span></a><span class="s0">(defaults are as shown below):</span>
<a name="l153"><span class="ln">153  </span></a>
<a name="l154"><span class="ln">154  </span></a><span class="s0">`allow_smtputf8=True`: Set to `False` to prohibit internationalized addresses that would</span>
<a name="l155"><span class="ln">155  </span></a>    <span class="s0">require the</span>
<a name="l156"><span class="ln">156  </span></a>    <span class="s0">[SMTPUTF8](https://tools.ietf.org/html/rfc6531) extension. You can also set `email_validator.ALLOW_SMTPUTF8` to `False` to turn it off for all calls by default.</span>
<a name="l157"><span class="ln">157  </span></a>
<a name="l158"><span class="ln">158  </span></a><span class="s0">`check_deliverability=True`: If true, DNS queries check that a non-null MX (or A/AAAA record as an MX fallback) is present for the domain-part of the email address and that a reject-all SPF record is not present. Set to `False` to skip these DNS checks. DNS is slow and sometimes unavailable, so consider whether these checks are useful for your use case. It is recommended to pass `False` when performing validation for login pages (but not account creation pages) since re-validation of the domain by querying DNS at every login is probably undesirable. You can also set `email_validator.CHECK_DELIVERABILITY` to `False` to turn this off for all calls by default.</span>
<a name="l159"><span class="ln">159  </span></a>
<a name="l160"><span class="ln">160  </span></a><span class="s0">`allow_empty_local=False`: Set to `True` to allow an empty local part (i.e.</span>
<a name="l161"><span class="ln">161  </span></a>    <span class="s0">`@example.com`), e.g. for validating Postfix aliases.</span>
<a name="l162"><span class="ln">162  </span></a>    
<a name="l163"><span class="ln">163  </span></a><span class="s0">`dns_resolver=None`: Pass an instance of [dns.resolver.Resolver](https://dnspython.readthedocs.io/en/latest/resolver-class.html) to control the DNS resolver including setting a timeout and [a cache](https://dnspython.readthedocs.io/en/latest/resolver-caching.html). The `caching_resolver` function shown above is a helper function to construct a dns.resolver.Resolver with a [LRUCache](https://dnspython.readthedocs.io/en/latest/resolver-caching.html#dns.resolver.LRUCache). Reuse the same resolver instance across calls to `validate_email` to make use of the cache.</span>
<a name="l164"><span class="ln">164  </span></a>
<a name="l165"><span class="ln">165  </span></a><span class="s0">`test_environment=False`: DNS-based deliverability checks are disabled and  `test` and `subdomain.test` domain names are permitted (see below). You can also set `email_validator.TEST_ENVIRONMENT` to `True` to turn it on for all calls by default.</span>
<a name="l166"><span class="ln">166  </span></a>
<a name="l167"><span class="ln">167  </span></a><span class="s0">### DNS timeout and cache</span>
<a name="l168"><span class="ln">168  </span></a>
<a name="l169"><span class="ln">169  </span></a><span class="s0">When validating many email addresses or to control the timeout (the default is 15 seconds), create a caching [dns.resolver.Resolver](https://dnspython.readthedocs.io/en/latest/resolver-class.html) to reuse in each call. The `caching_resolver` function returns one easily for you:</span>
<a name="l170"><span class="ln">170  </span></a>
<a name="l171"><span class="ln">171  </span></a><span class="s0">```python</span>
<a name="l172"><span class="ln">172  </span></a><span class="s0">from email_validator import validate_email, caching_resolver</span>
<a name="l173"><span class="ln">173  </span></a>
<a name="l174"><span class="ln">174  </span></a><span class="s0">resolver = caching_resolver(timeout=10)</span>
<a name="l175"><span class="ln">175  </span></a>
<a name="l176"><span class="ln">176  </span></a><span class="s0">while True:</span>
<a name="l177"><span class="ln">177  </span></a>  <span class="s0">email = validate_email(email, dns_resolver=resolver).email</span>
<a name="l178"><span class="ln">178  </span></a><span class="s0">```</span>
<a name="l179"><span class="ln">179  </span></a>
<a name="l180"><span class="ln">180  </span></a><span class="s0">### Test addresses</span>
<a name="l181"><span class="ln">181  </span></a>
<a name="l182"><span class="ln">182  </span></a><span class="s0">This library rejects email addresess that use the [Special Use Domain Names](https://www.iana.org/assignments/special-use-domain-names/special-use-domain-names.xhtml) `invalid`, `localhost`, `test`, and some others by raising `EmailSyntaxError`. This is to protect your system from abuse: You probably don't want a user to be able to cause an email to be sent to `localhost`. However, in your non-production test environments you may want to use `@test` or `@myname.test` email addresses. There are three ways you can allow this:</span>
<a name="l183"><span class="ln">183  </span></a>
<a name="l184"><span class="ln">184  </span></a><span class="s0">1. Add `test_environment=True` to the call to `validate_email` (see above).</span>
<a name="l185"><span class="ln">185  </span></a><span class="s0">2. Set `email_validator.TEST_ENVIRONMENT` to `True`.</span>
<a name="l186"><span class="ln">186  </span></a><span class="s0">3. Remove the special-use domain name that you want to use from `email_validator.SPECIAL_USE_DOMAIN_NAMES`:</span>
<a name="l187"><span class="ln">187  </span></a>
<a name="l188"><span class="ln">188  </span></a><span class="s0">```python</span>
<a name="l189"><span class="ln">189  </span></a><span class="s0">import email_validator</span>
<a name="l190"><span class="ln">190  </span></a><span class="s0">email_validator.SPECIAL_USE_DOMAIN_NAMES.remove(&quot;test&quot;)</span>
<a name="l191"><span class="ln">191  </span></a><span class="s0">```</span>
<a name="l192"><span class="ln">192  </span></a>
<a name="l193"><span class="ln">193  </span></a><span class="s0">It is tempting to use `@example.com/net/org` in tests. These domains are reserved to IANA for use in documentation so there is no risk of accidentally emailing someone at those domains. But beware that this library will reject these domain names if DNS-based deliverability checks are not disabled because these domains do not resolve to domains that accept email. In tests, consider using your own domain name or `@test` or `@myname.test` instead.</span>
<a name="l194"><span class="ln">194  </span></a>
<a name="l195"><span class="ln">195  </span></a><span class="s0">Internationalized email addresses</span>
<a name="l196"><span class="ln">196  </span></a><span class="s0">---------------------------------</span>
<a name="l197"><span class="ln">197  </span></a>
<a name="l198"><span class="ln">198  </span></a><span class="s0">The email protocol SMTP and the domain name system DNS have historically</span>
<a name="l199"><span class="ln">199  </span></a><span class="s0">only allowed English (ASCII) characters in email addresses and domain names,</span>
<a name="l200"><span class="ln">200  </span></a><span class="s0">respectively. Each has adapted to internationalization in a separate</span>
<a name="l201"><span class="ln">201  </span></a><span class="s0">way, creating two separate aspects to email address</span>
<a name="l202"><span class="ln">202  </span></a><span class="s0">internationalization.</span>
<a name="l203"><span class="ln">203  </span></a>
<a name="l204"><span class="ln">204  </span></a><span class="s0">### Internationalized domain names (IDN)</span>
<a name="l205"><span class="ln">205  </span></a>
<a name="l206"><span class="ln">206  </span></a><span class="s0">The first is [internationalized domain names (RFC</span>
<a name="l207"><span class="ln">207  </span></a><span class="s0">5891)](https://tools.ietf.org/html/rfc5891), a.k.a IDNA 2008. The DNS</span>
<a name="l208"><span class="ln">208  </span></a><span class="s0">system has not been updated with Unicode support. Instead, internationalized</span>
<a name="l209"><span class="ln">209  </span></a><span class="s0">domain names are converted into a special IDNA ASCII &quot;[Punycode](https://www.rfc-editor.org/rfc/rfc3492.txt)&quot;</span>
<a name="l210"><span class="ln">210  </span></a><span class="s0">form starting with `xn--`. When an email address has non-ASCII</span>
<a name="l211"><span class="ln">211  </span></a><span class="s0">characters in its domain part, the domain part is replaced with its IDNA</span>
<a name="l212"><span class="ln">212  </span></a><span class="s0">ASCII equivalent form in the process of mail transmission. Your mail</span>
<a name="l213"><span class="ln">213  </span></a><span class="s0">submission library probably does this for you transparently. Note that</span>
<a name="l214"><span class="ln">214  </span></a><span class="s0">most web browsers are currently in transition between IDNA 2003 (RFC</span>
<a name="l215"><span class="ln">215  </span></a><span class="s0">3490) and IDNA 2008 (RFC 5891) and [compliance around the web is not</span>
<a name="l216"><span class="ln">216  </span></a><span class="s0">very</span>
<a name="l217"><span class="ln">217  </span></a><span class="s0">good](http://archives.miloush.net/michkap/archive/2012/02/27/10273315.html)</span>
<a name="l218"><span class="ln">218  </span></a><span class="s0">in any case, so be aware that edge cases are handled differently by</span>
<a name="l219"><span class="ln">219  </span></a><span class="s0">different applications and libraries. This library conforms to IDNA 2008</span>
<a name="l220"><span class="ln">220  </span></a><span class="s0">using the [idna](https://github.com/kjd/idna) module by Kim Davies.</span>
<a name="l221"><span class="ln">221  </span></a>
<a name="l222"><span class="ln">222  </span></a><span class="s0">### Internationalized local parts</span>
<a name="l223"><span class="ln">223  </span></a>
<a name="l224"><span class="ln">224  </span></a><span class="s0">The second sort of internationalization is internationalization in the</span>
<a name="l225"><span class="ln">225  </span></a><span class="s0">*local* part of the address (before the @-sign). In non-internationalized</span>
<a name="l226"><span class="ln">226  </span></a><span class="s0">email addresses, only English letters, numbers, and some punctuation</span>
<a name="l227"><span class="ln">227  </span></a><span class="s0">(`._!#$%&amp;'^``*+-=~/?{|}`) are allowed. In internationalized email address</span>
<a name="l228"><span class="ln">228  </span></a><span class="s0">local parts, a wider range of Unicode characters are allowed.</span>
<a name="l229"><span class="ln">229  </span></a>
<a name="l230"><span class="ln">230  </span></a><span class="s0">A surprisingly large number of Unicode characters are not safe to display,</span>
<a name="l231"><span class="ln">231  </span></a><span class="s0">especially when the email address is concatenated with other text, so this</span>
<a name="l232"><span class="ln">232  </span></a><span class="s0">library tries to protect you by not permitting resvered, non-, private use,</span>
<a name="l233"><span class="ln">233  </span></a><span class="s0">formatting (which can be used to alter the display order of characters),</span>
<a name="l234"><span class="ln">234  </span></a><span class="s0">whitespace, and control characters, and combining characters</span>
<a name="l235"><span class="ln">235  </span></a><span class="s0">as the first character (so that they cannot combine with something outside</span>
<a name="l236"><span class="ln">236  </span></a><span class="s0">of the email address string). See https://qntm.org/safe and https://trojansource.codes/</span>
<a name="l237"><span class="ln">237  </span></a><span class="s0">for relevant prior work. (Other than whitespace, these are checks that</span>
<a name="l238"><span class="ln">238  </span></a><span class="s0">you should be applying to nearly all user inputs in a security-sensitive</span>
<a name="l239"><span class="ln">239  </span></a><span class="s0">context.)</span>
<a name="l240"><span class="ln">240  </span></a>
<a name="l241"><span class="ln">241  </span></a><span class="s0">These character checks are performed after Unicode normalization (see below),</span>
<a name="l242"><span class="ln">242  </span></a><span class="s0">so you are only fully protected if you replace all user-provided email addresses</span>
<a name="l243"><span class="ln">243  </span></a><span class="s0">with the normalized email address string returned by this library. This does not</span>
<a name="l244"><span class="ln">244  </span></a><span class="s0">guard against the well known problem that many Unicode characters look alike</span>
<a name="l245"><span class="ln">245  </span></a><span class="s0">(or are identical), which can be used to fool humans reading displayed text.</span>
<a name="l246"><span class="ln">246  </span></a>
<a name="l247"><span class="ln">247  </span></a><span class="s0">Email addresses with these non-ASCII characters require that your mail</span>
<a name="l248"><span class="ln">248  </span></a><span class="s0">submission library and the mail servers along the route to the destination,</span>
<a name="l249"><span class="ln">249  </span></a><span class="s0">including your own outbound mail server, all support the</span>
<a name="l250"><span class="ln">250  </span></a><span class="s0">[SMTPUTF8 (RFC 6531)](https://tools.ietf.org/html/rfc6531) extension.</span>
<a name="l251"><span class="ln">251  </span></a><span class="s0">Support for SMTPUTF8 varies. See the `allow_smtputf8` parameter.</span>
<a name="l252"><span class="ln">252  </span></a>
<a name="l253"><span class="ln">253  </span></a><span class="s0">### If you know ahead of time that SMTPUTF8 is not supported by your mail submission stack</span>
<a name="l254"><span class="ln">254  </span></a>
<a name="l255"><span class="ln">255  </span></a><span class="s0">By default all internationalized forms are accepted by the validator.</span>
<a name="l256"><span class="ln">256  </span></a><span class="s0">But if you know ahead of time that SMTPUTF8 is not supported by your</span>
<a name="l257"><span class="ln">257  </span></a><span class="s0">mail submission stack, then you must filter out addresses that require</span>
<a name="l258"><span class="ln">258  </span></a><span class="s0">SMTPUTF8 using the `allow_smtputf8=False` keyword argument (see above).</span>
<a name="l259"><span class="ln">259  </span></a><span class="s0">This will cause the validation function to raise a `EmailSyntaxError` if</span>
<a name="l260"><span class="ln">260  </span></a><span class="s0">delivery would require SMTPUTF8. That's just in those cases where</span>
<a name="l261"><span class="ln">261  </span></a><span class="s0">non-ASCII characters appear before the @-sign. If you do not set</span>
<a name="l262"><span class="ln">262  </span></a><span class="s0">`allow_smtputf8=False`, you can also check the value of the `smtputf8`</span>
<a name="l263"><span class="ln">263  </span></a><span class="s0">field in the returned object.</span>
<a name="l264"><span class="ln">264  </span></a>
<a name="l265"><span class="ln">265  </span></a><span class="s0">If your mail submission library doesn't support Unicode at all --- even</span>
<a name="l266"><span class="ln">266  </span></a><span class="s0">in the domain part of the address --- then immediately prior to mail</span>
<a name="l267"><span class="ln">267  </span></a><span class="s0">submission you must replace the email address with its ASCII-ized form.</span>
<a name="l268"><span class="ln">268  </span></a><span class="s0">This library gives you back the ASCII-ized form in the `ascii_email`</span>
<a name="l269"><span class="ln">269  </span></a><span class="s0">field in the returned object, which you can get like this:</span>
<a name="l270"><span class="ln">270  </span></a>
<a name="l271"><span class="ln">271  </span></a><span class="s0">```python</span>
<a name="l272"><span class="ln">272  </span></a><span class="s0">valid = validate_email(email, allow_smtputf8=False)</span>
<a name="l273"><span class="ln">273  </span></a><span class="s0">email = valid.ascii_email</span>
<a name="l274"><span class="ln">274  </span></a><span class="s0">```</span>
<a name="l275"><span class="ln">275  </span></a>
<a name="l276"><span class="ln">276  </span></a><span class="s0">The local part is left alone (if it has internationalized characters</span>
<a name="l277"><span class="ln">277  </span></a><span class="s0">`allow_smtputf8=False` will force validation to fail) and the domain</span>
<a name="l278"><span class="ln">278  </span></a><span class="s0">part is converted to [IDNA ASCII](https://tools.ietf.org/html/rfc5891).</span>
<a name="l279"><span class="ln">279  </span></a><span class="s0">(You probably should not do this at account creation time so you don't</span>
<a name="l280"><span class="ln">280  </span></a><span class="s0">change the user's login information without telling them.)</span>
<a name="l281"><span class="ln">281  </span></a>
<a name="l282"><span class="ln">282  </span></a><span class="s0">### UCS-4 support required for Python 2.7</span>
<a name="l283"><span class="ln">283  </span></a>
<a name="l284"><span class="ln">284  </span></a><span class="s0">This library hopefully still works with Python 2.7.</span>
<a name="l285"><span class="ln">285  </span></a><span class="s0">Note that when using Python 2.7, it is required that it was built with</span>
<a name="l286"><span class="ln">286  </span></a><span class="s0">UCS-4 support (see</span>
<a name="l287"><span class="ln">287  </span></a><span class="s0">[here](https://stackoverflow.com/questions/29109944/python-returns-length-of-2-for-single-unicode-character-string));</span>
<a name="l288"><span class="ln">288  </span></a><span class="s0">otherwise emails with unicode characters outside of the BMP (Basic</span>
<a name="l289"><span class="ln">289  </span></a><span class="s0">Multilingual Plane) will not validate correctly.</span>
<a name="l290"><span class="ln">290  </span></a>
<a name="l291"><span class="ln">291  </span></a><span class="s0">Normalization</span>
<a name="l292"><span class="ln">292  </span></a><span class="s0">-------------</span>
<a name="l293"><span class="ln">293  </span></a>
<a name="l294"><span class="ln">294  </span></a><span class="s0">The use of Unicode in email addresses introduced a normalization</span>
<a name="l295"><span class="ln">295  </span></a><span class="s0">problem. Different Unicode strings can look identical and have the same</span>
<a name="l296"><span class="ln">296  </span></a><span class="s0">semantic meaning to the user. The `email` field returned on successful</span>
<a name="l297"><span class="ln">297  </span></a><span class="s0">validation provides the correctly normalized form of the given email</span>
<a name="l298"><span class="ln">298  </span></a><span class="s0">address:</span>
<a name="l299"><span class="ln">299  </span></a>
<a name="l300"><span class="ln">300  </span></a><span class="s0">```python</span>
<a name="l301"><span class="ln">301  </span></a><span class="s0">valid = validate_email(&quot;me@Ｄｏｍａｉｎ.com&quot;)</span>
<a name="l302"><span class="ln">302  </span></a><span class="s0">email = valid.ascii_email</span>
<a name="l303"><span class="ln">303  </span></a><span class="s0">print(email)</span>
<a name="l304"><span class="ln">304  </span></a><span class="s0"># prints: me@domain.com</span>
<a name="l305"><span class="ln">305  </span></a><span class="s0">```</span>
<a name="l306"><span class="ln">306  </span></a>
<a name="l307"><span class="ln">307  </span></a><span class="s0">Because an end-user might type their email address in different (but</span>
<a name="l308"><span class="ln">308  </span></a><span class="s0">equivalent) un-normalized forms at different times, you ought to</span>
<a name="l309"><span class="ln">309  </span></a><span class="s0">replace what they enter with the normalized form immediately prior to</span>
<a name="l310"><span class="ln">310  </span></a><span class="s0">going into your database (during account creation), querying your database</span>
<a name="l311"><span class="ln">311  </span></a><span class="s0">(during login), or sending outbound mail. Normalization may also change</span>
<a name="l312"><span class="ln">312  </span></a><span class="s0">the length of an email address, and this may affect whether it is valid</span>
<a name="l313"><span class="ln">313  </span></a><span class="s0">and acceptable by your SMTP provider.</span>
<a name="l314"><span class="ln">314  </span></a>
<a name="l315"><span class="ln">315  </span></a><span class="s0">The normalizations include lowercasing the domain part of the email</span>
<a name="l316"><span class="ln">316  </span></a><span class="s0">address (domain names are case-insensitive), [Unicode &quot;NFC&quot;</span>
<a name="l317"><span class="ln">317  </span></a><span class="s0">normalization](https://en.wikipedia.org/wiki/Unicode_equivalence) of the</span>
<a name="l318"><span class="ln">318  </span></a><span class="s0">whole address (which turns characters plus [combining</span>
<a name="l319"><span class="ln">319  </span></a><span class="s0">characters](https://en.wikipedia.org/wiki/Combining_character) into</span>
<a name="l320"><span class="ln">320  </span></a><span class="s0">precomposed characters where possible, replacement of [fullwidth and</span>
<a name="l321"><span class="ln">321  </span></a><span class="s0">halfwidth</span>
<a name="l322"><span class="ln">322  </span></a><span class="s0">characters](https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms)</span>
<a name="l323"><span class="ln">323  </span></a><span class="s0">in the domain part, possibly other</span>
<a name="l324"><span class="ln">324  </span></a><span class="s0">[UTS46](http://unicode.org/reports/tr46) mappings on the domain part,</span>
<a name="l325"><span class="ln">325  </span></a><span class="s0">and conversion from Punycode to Unicode characters.</span>
<a name="l326"><span class="ln">326  </span></a>
<a name="l327"><span class="ln">327  </span></a><span class="s0">(See [RFC 6532 (internationalized email) section</span>
<a name="l328"><span class="ln">328  </span></a><span class="s0">3.1](https://tools.ietf.org/html/rfc6532#section-3.1) and [RFC 5895</span>
<a name="l329"><span class="ln">329  </span></a><span class="s0">(IDNA 2008) section 2](http://www.ietf.org/rfc/rfc5895.txt).)</span>
<a name="l330"><span class="ln">330  </span></a>
<a name="l331"><span class="ln">331  </span></a><span class="s0">Examples</span>
<a name="l332"><span class="ln">332  </span></a><span class="s0">--------</span>
<a name="l333"><span class="ln">333  </span></a>
<a name="l334"><span class="ln">334  </span></a><span class="s0">For the email address `test@joshdata.me`, the returned object is:</span>
<a name="l335"><span class="ln">335  </span></a>
<a name="l336"><span class="ln">336  </span></a><span class="s0">```python</span>
<a name="l337"><span class="ln">337  </span></a><span class="s0">ValidatedEmail(</span>
<a name="l338"><span class="ln">338  </span></a>  <span class="s0">email='test@joshdata.me',</span>
<a name="l339"><span class="ln">339  </span></a>  <span class="s0">local_part='test',</span>
<a name="l340"><span class="ln">340  </span></a>  <span class="s0">domain='joshdata.me',</span>
<a name="l341"><span class="ln">341  </span></a>  <span class="s0">ascii_email='test@joshdata.me',</span>
<a name="l342"><span class="ln">342  </span></a>  <span class="s0">ascii_local_part='test',</span>
<a name="l343"><span class="ln">343  </span></a>  <span class="s0">ascii_domain='joshdata.me',</span>
<a name="l344"><span class="ln">344  </span></a>  <span class="s0">smtputf8=False)</span>
<a name="l345"><span class="ln">345  </span></a><span class="s0">```</span>
<a name="l346"><span class="ln">346  </span></a>
<a name="l347"><span class="ln">347  </span></a><span class="s0">For the fictitious address `example@ツ.life`, which has an</span>
<a name="l348"><span class="ln">348  </span></a><span class="s0">internationalized domain but ASCII local part, the returned object is:</span>
<a name="l349"><span class="ln">349  </span></a>
<a name="l350"><span class="ln">350  </span></a><span class="s0">```python</span>
<a name="l351"><span class="ln">351  </span></a><span class="s0">ValidatedEmail(</span>
<a name="l352"><span class="ln">352  </span></a>  <span class="s0">email='example@ツ.life',</span>
<a name="l353"><span class="ln">353  </span></a>  <span class="s0">local_part='example',</span>
<a name="l354"><span class="ln">354  </span></a>  <span class="s0">domain='ツ.life',</span>
<a name="l355"><span class="ln">355  </span></a>  <span class="s0">ascii_email='example@xn--bdk.life',</span>
<a name="l356"><span class="ln">356  </span></a>  <span class="s0">ascii_local_part='example',</span>
<a name="l357"><span class="ln">357  </span></a>  <span class="s0">ascii_domain='xn--bdk.life',</span>
<a name="l358"><span class="ln">358  </span></a>  <span class="s0">smtputf8=False)</span>
<a name="l359"><span class="ln">359  </span></a>
<a name="l360"><span class="ln">360  </span></a><span class="s0">```</span>
<a name="l361"><span class="ln">361  </span></a>
<a name="l362"><span class="ln">362  </span></a><span class="s0">Note that `smtputf8` is `False` even though the domain part is</span>
<a name="l363"><span class="ln">363  </span></a><span class="s0">internationalized because</span>
<a name="l364"><span class="ln">364  </span></a><span class="s0">[SMTPUTF8](https://tools.ietf.org/html/rfc6531) is only needed if the</span>
<a name="l365"><span class="ln">365  </span></a><span class="s0">local part of the address is internationalized (the domain part can be</span>
<a name="l366"><span class="ln">366  </span></a><span class="s0">converted to IDNA ASCII Punycode). Also note that the `email` and `domain`</span>
<a name="l367"><span class="ln">367  </span></a><span class="s0">fields provide a normalized form of the email address and domain name</span>
<a name="l368"><span class="ln">368  </span></a><span class="s0">(casefolding and Unicode normalization as required by IDNA 2008).</span>
<a name="l369"><span class="ln">369  </span></a>
<a name="l370"><span class="ln">370  </span></a><span class="s0">Calling `validate_email` with the ASCII form of the above email address,</span>
<a name="l371"><span class="ln">371  </span></a><span class="s0">`example@xn--bdk.life`, returns the exact same information (i.e., the</span>
<a name="l372"><span class="ln">372  </span></a><span class="s0">`email` field always will contain Unicode characters, not Punycode).</span>
<a name="l373"><span class="ln">373  </span></a>
<a name="l374"><span class="ln">374  </span></a><span class="s0">For the fictitious address `ツ-test@joshdata.me`, which has an</span>
<a name="l375"><span class="ln">375  </span></a><span class="s0">internationalized local part, the returned object is:</span>
<a name="l376"><span class="ln">376  </span></a>
<a name="l377"><span class="ln">377  </span></a><span class="s0">```python</span>
<a name="l378"><span class="ln">378  </span></a><span class="s0">ValidatedEmail(</span>
<a name="l379"><span class="ln">379  </span></a>  <span class="s0">email='ツ-test@joshdata.me',</span>
<a name="l380"><span class="ln">380  </span></a>  <span class="s0">local_part='ツ-test',</span>
<a name="l381"><span class="ln">381  </span></a>  <span class="s0">domain='joshdata.me',</span>
<a name="l382"><span class="ln">382  </span></a>  <span class="s0">ascii_email=None,</span>
<a name="l383"><span class="ln">383  </span></a>  <span class="s0">ascii_local_part=None,</span>
<a name="l384"><span class="ln">384  </span></a>  <span class="s0">ascii_domain='joshdata.me',</span>
<a name="l385"><span class="ln">385  </span></a>  <span class="s0">smtputf8=True)</span>
<a name="l386"><span class="ln">386  </span></a><span class="s0">```</span>
<a name="l387"><span class="ln">387  </span></a>
<a name="l388"><span class="ln">388  </span></a><span class="s0">Now `smtputf8` is `True` and `ascii_email` is `None` because the local</span>
<a name="l389"><span class="ln">389  </span></a><span class="s0">part of the address is internationalized. The `local_part` and `email` fields</span>
<a name="l390"><span class="ln">390  </span></a><span class="s0">return the normalized form of the address: certain Unicode characters</span>
<a name="l391"><span class="ln">391  </span></a><span class="s0">(such as angstrom and ohm) may be replaced by other equivalent code</span>
<a name="l392"><span class="ln">392  </span></a><span class="s0">points (a-with-ring and omega).</span>
<a name="l393"><span class="ln">393  </span></a>
<a name="l394"><span class="ln">394  </span></a><span class="s0">Return value</span>
<a name="l395"><span class="ln">395  </span></a><span class="s0">------------</span>
<a name="l396"><span class="ln">396  </span></a>
<a name="l397"><span class="ln">397  </span></a><span class="s0">When an email address passes validation, the fields in the returned object</span>
<a name="l398"><span class="ln">398  </span></a><span class="s0">are:</span>
<a name="l399"><span class="ln">399  </span></a>
<a name="l400"><span class="ln">400  </span></a><span class="s0">| Field | Value |</span>
<a name="l401"><span class="ln">401  </span></a><span class="s0">| -----:|-------|</span>
<a name="l402"><span class="ln">402  </span></a><span class="s0">| `email` | The normalized form of the email address that you should put in your database. This merely combines the `local_part` and `domain` fields (see below). |</span>
<a name="l403"><span class="ln">403  </span></a><span class="s0">| `ascii_email` | If set, an ASCII-only form of the email address by replacing the domain part with [IDNA](https://tools.ietf.org/html/rfc5891) [Punycode](https://www.rfc-editor.org/rfc/rfc3492.txt). This field will be present when an ASCII-only form of the email address exists (including if the email address is already ASCII). If the local part of the email address contains internationalized characters, `ascii_email` will be `None`. If set, it merely combines `ascii_local_part` and `ascii_domain`. |</span>
<a name="l404"><span class="ln">404  </span></a><span class="s0">| `local_part` | The local part of the given email address (before the @-sign) with Unicode NFC normalization applied. |</span>
<a name="l405"><span class="ln">405  </span></a><span class="s0">| `ascii_local_part` | If set, the local part, which is composed of ASCII characters only. |</span>
<a name="l406"><span class="ln">406  </span></a><span class="s0">| `domain` | The canonical internationalized Unicode form of the domain part of the email address. If the returned string contains non-ASCII characters, either the [SMTPUTF8](https://tools.ietf.org/html/rfc6531) feature of your mail relay will be required to transmit the message or else the email address's domain part must be converted to IDNA ASCII first: Use `ascii_domain` field instead. |</span>
<a name="l407"><span class="ln">407  </span></a><span class="s0">| `ascii_domain` | The [IDNA](https://tools.ietf.org/html/rfc5891) [Punycode](https://www.rfc-editor.org/rfc/rfc3492.txt)-encoded form of the domain part of the given email address, as it would be transmitted on the wire. |</span>
<a name="l408"><span class="ln">408  </span></a><span class="s0">| `smtputf8` | A boolean indicating that the [SMTPUTF8](https://tools.ietf.org/html/rfc6531) feature of your mail relay will be required to transmit messages to this address because the local part of the address has non-ASCII characters (the local part cannot be IDNA-encoded). If `allow_smtputf8=False` is passed as an argument, this flag will always be false because an exception is raised if it would have been true. |</span>
<a name="l409"><span class="ln">409  </span></a><span class="s0">| `mx` | A list of (priority, domain) tuples of MX records specified in the DNS for the domain (see [RFC 5321 section 5](https://tools.ietf.org/html/rfc5321#section-5)). May be `None` if the deliverability check could not be completed because of a temporary issue like a timeout. |</span>
<a name="l410"><span class="ln">410  </span></a><span class="s0">| `mx_fallback_type` | `None` if an `MX` record is found. If no MX records are actually specified in DNS and instead are inferred, through an obsolete mechanism, from A or AAAA records, the value is the type of DNS record used instead (`A` or `AAAA`). May be `None` if the deliverability check could not be completed because of a temporary issue like a timeout. |</span>
<a name="l411"><span class="ln">411  </span></a><span class="s0">| `spf` | Any SPF record found while checking deliverability. |</span>
<a name="l412"><span class="ln">412  </span></a>
<a name="l413"><span class="ln">413  </span></a><span class="s0">Assumptions</span>
<a name="l414"><span class="ln">414  </span></a><span class="s0">-----------</span>
<a name="l415"><span class="ln">415  </span></a>
<a name="l416"><span class="ln">416  </span></a><span class="s0">By design, this validator does not pass all email addresses that</span>
<a name="l417"><span class="ln">417  </span></a><span class="s0">strictly conform to the standards. Many email address forms are obsolete</span>
<a name="l418"><span class="ln">418  </span></a><span class="s0">or likely to cause trouble:</span>
<a name="l419"><span class="ln">419  </span></a>
<a name="l420"><span class="ln">420  </span></a><span class="s0">* The validator assumes the email address is intended to be</span>
<a name="l421"><span class="ln">421  </span></a>  <span class="s0">usable on the public Internet. The domain part</span>
<a name="l422"><span class="ln">422  </span></a>  <span class="s0">of the email address must be a resolvable domain name</span>
<a name="l423"><span class="ln">423  </span></a>  <span class="s0">(without NULL MX or SPF -all DNS records) if deliverability</span>
<a name="l424"><span class="ln">424  </span></a>  <span class="s0">checks are turned on.</span>
<a name="l425"><span class="ln">425  </span></a>  <span class="s0">Most [Special Use Domain Names](https://www.iana.org/assignments/special-use-domain-names/special-use-domain-names.xhtml)</span>
<a name="l426"><span class="ln">426  </span></a>  <span class="s0">and their subdomains and</span>
<a name="l427"><span class="ln">427  </span></a>  <span class="s0">domain names without a `.` are rejected as a syntax error</span>
<a name="l428"><span class="ln">428  </span></a>  <span class="s0">(except see the `test_environment` parameter above).</span>
<a name="l429"><span class="ln">429  </span></a><span class="s0">* Obsolete email syntaxes are rejected:</span>
<a name="l430"><span class="ln">430  </span></a>  <span class="s0">The &quot;quoted string&quot; form of the local part of the email address (RFC</span>
<a name="l431"><span class="ln">431  </span></a>  <span class="s0">5321 4.1.2) is not permitted.</span>
<a name="l432"><span class="ln">432  </span></a>  <span class="s0">Quoted forms allow multiple @-signs, space characters, and other</span>
<a name="l433"><span class="ln">433  </span></a>  <span class="s0">troublesome conditions. The unsual [(comment) syntax](https://github.com/JoshData/python-email-validator/issues/77)</span>
<a name="l434"><span class="ln">434  </span></a>  <span class="s0">is also rejected. The &quot;literal&quot; form for the domain part of an email address (an</span>
<a name="l435"><span class="ln">435  </span></a>  <span class="s0">IP address in brackets) is rejected. Other obsolete and deprecated syntaxes are</span>
<a name="l436"><span class="ln">436  </span></a>  <span class="s0">rejected. No one uses these forms anymore.</span>
<a name="l437"><span class="ln">437  </span></a>
<a name="l438"><span class="ln">438  </span></a><span class="s0">Testing</span>
<a name="l439"><span class="ln">439  </span></a><span class="s0">-------</span>
<a name="l440"><span class="ln">440  </span></a>
<a name="l441"><span class="ln">441  </span></a><span class="s0">Tests can be run using</span>
<a name="l442"><span class="ln">442  </span></a>
<a name="l443"><span class="ln">443  </span></a><span class="s0">```sh</span>
<a name="l444"><span class="ln">444  </span></a><span class="s0">pip install -r test_requirements.txt </span>
<a name="l445"><span class="ln">445  </span></a><span class="s0">make test</span>
<a name="l446"><span class="ln">446  </span></a><span class="s0">```</span>
<a name="l447"><span class="ln">447  </span></a>
<a name="l448"><span class="ln">448  </span></a><span class="s0">For Project Maintainers</span>
<a name="l449"><span class="ln">449  </span></a><span class="s0">-----------------------</span>
<a name="l450"><span class="ln">450  </span></a>
<a name="l451"><span class="ln">451  </span></a><span class="s0">The package is distributed as a universal wheel and as a source package.</span>
<a name="l452"><span class="ln">452  </span></a>
<a name="l453"><span class="ln">453  </span></a><span class="s0">To release:</span>
<a name="l454"><span class="ln">454  </span></a>
<a name="l455"><span class="ln">455  </span></a><span class="s0">* Update CHANGELOG.md.</span>
<a name="l456"><span class="ln">456  </span></a><span class="s0">* Update the version number in setup.cfg.</span>
<a name="l457"><span class="ln">457  </span></a><span class="s0">* Make a commit with the new version number.</span>
<a name="l458"><span class="ln">458  </span></a><span class="s0">* Follow the steps below to publish source and a universal wheel to pypi and tag the release.</span>
<a name="l459"><span class="ln">459  </span></a><span class="s0">* Make a release at https://github.com/JoshData/python-email-validator/releases/new.</span>
<a name="l460"><span class="ln">460  </span></a>
<a name="l461"><span class="ln">461  </span></a><span class="s0">```sh</span>
<a name="l462"><span class="ln">462  </span></a><span class="s0">./release_to_pypi.sh</span>
<a name="l463"><span class="ln">463  </span></a><span class="s0">git tag v1.0.XXX # replace with version in setup.cfg</span>
<a name="l464"><span class="ln">464  </span></a><span class="s0">git push --tags</span>
<a name="l465"><span class="ln">465  </span></a><span class="s0">```</span>
<a name="l466"><span class="ln">466  </span></a>
<a name="l467"><span class="ln">467  </span></a><span class="s0">Notes: The wheel is specified as universal in the file `setup.cfg` by the `universal = 1` key in the</span>
<a name="l468"><span class="ln">468  </span></a><span class="s0">`[bdist_wheel]` section.</span>
<a name="l469"><span class="ln">469  </span></a>
<a name="l470"><span class="ln">470  </span></a>
<a name="l471"><span class="ln">471  </span></a></pre>
</body>
</html>